# Домашнее задание к занятию 6. «Troubleshooting»

## Решение к Задаче 1

>- напишите список операций, которые вы будете производить для остановки запроса пользователя

Команда возвращает в ответе opid всех активных операций базы данных db1, которые выполняются дольше 180 секунд.

```sql
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```

Принудительно останавливаем операцию.

```sql
db.killOp(<opid>)
```

>- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

- Для оценки производительности текущих операций можно использовать Database Profiler, настроив профилирование БД с указанием порогового значения для медленных операций, но при этом нужно учитывать, что профилирование влияет на производительность БД.
- Изучить механизм выполнения запросов командой `explain`.
- Настроить процедуру `maxTimeMS()`, указав ограничение по времени для операций.
- Оптимизировать производительность запросов путём создания индексов для поддержки запросов, но при этом нужно учитывать, что индексы влияют на производительность операций записи.
- Использовать метод распределения данных по нескольким машинам - sharding.

## Решение к Задаче 2

> При масштабировании сервиса до N реплик вы увидели, что:
>
> - сначала рост отношения записанных значений к истекшим
> - Redis блокирует операции записи
>
> Как вы думаете, в чем может быть проблема?

Redis блокирует операции записи при росте отношения записанных key-value значений к истекшим более 25% от общего количества ключей.

## Решение к Задаче 3

> Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:
>
> `InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '`
>
>Как вы думаете, почему это начало происходить и как локализовать проблему?
>Какие пути решения этой проблемы вы можете предложить?

- БД не может обработать объемные запросы из-за низкого значения параметра `net_read_timeout`
- Медленный канал связи на стороне клиента или сервера, решается увеличением значения параметра `connect_timeout`
- Размер запроса превышает размер буфера, решается увеличением значения переменной `max_allowed_packet` на стороне сервера или опцией `--max_allowed_packet` на стороне клиента

## Решение к Задаче 4

>Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.
>После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что: `postmaster invoked oom-killer`
>>Как вы думаете, что происходит?
>Как бы вы решили эту проблему?

Сообщение от dmesg `postmaster invoked oom-killer` говорит о том, что механизм ядра Linux OOM Killer при исчерпании доступной памяти RAM принудительно завершил процесс Postmaster. Для решения проблемы есть несколько способов, самый тривиальный это добавить RAM, а если без вложения средств, то стоит обратить внимание на некоторые настройки ядра Linux:

- Отключение механизма OOM Killer - не рекомендуется т.к. механизм отвечает за стабильность работы системы.
- vm.overcommit_memory=2 - не позволит избежать OOM Killer на 100%, но уменьшит вероятность завершения процесса PgSQL
- swapness - настройка файла подкачки, что не увеличит память, но повлияет на эффективность базы данных.

И если используются облачные технологии, то стоит обратить внимание на некоторые настройки самого PostgreSQL:

- shared_buffers - буфер обмена PostgreSQL, этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.
- work_mem - эта настройка используется для сложной сортировки.
- temp_buffers - задаёт максимальный объём памяти, выделяемой для временных буферов в каждом сеансе.
- maintenance_work_mem - задаёт максимальный объём памяти для операций обслуживания БД.
